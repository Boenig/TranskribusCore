package eu.transkribus.core.model.beans.pagecontent_old;

// THIS FILE WAS GENERATED BY HANS MAULWURF

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Observer;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlElements;
import javax.xml.bind.annotation.XmlID;
import javax.xml.bind.annotation.XmlSchemaType;
import javax.xml.bind.annotation.XmlSeeAlso;
import javax.xml.bind.annotation.XmlTransient;
import javax.xml.bind.annotation.XmlType;
import javax.xml.bind.annotation.adapters.CollapsedStringAdapter;
import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import eu.transkribus.core.exceptions.NotImplementedException;
import eu.transkribus.core.model.beans.customtags.CustomTagList;
import eu.transkribus.core.model.beans.customtags.CustomTagUtil;
import eu.transkribus.core.model.beans.customtags.TextStyleTag;
import eu.transkribus.core.model.beans.pagecontent_extension.observable.TrpObservable;
import eu.transkribus.core.model.beans.pagecontent_extension.observable.TrpObserveEvent.TrpChildrenClearedEvent;
import eu.transkribus.core.model.beans.pagecontent_extension.observable.TrpObserveEvent.TrpConstructedWithParentEvent;
import eu.transkribus.core.model.beans.pagecontent_extension.observable.TrpObserveEvent.TrpCoordsChangedEvent;
import eu.transkribus.core.model.beans.pagecontent_extension.observable.TrpObserveEvent.TrpReadingOrderChangedEvent;
import eu.transkribus.core.model.beans.pagecontent_extension.observable.TrpObserveEvent.TrpReinsertIntoParentEvent;
import eu.transkribus.core.model.beans.pagecontent_extension.observable.TrpObserveEvent.TrpRemovedEvent;
import eu.transkribus.core.model.beans.pagecontent_trp.ITrpShapeType;
import eu.transkribus.core.model.beans.pagecontent_trp.RegionTypeUtil;
import eu.transkribus.core.model.beans.pagecontent_trp.TrpElementReadingOrderComparator;
import eu.transkribus.core.model.beans.pagecontent_trp.TrpPageType;
import eu.transkribus.core.model.beans.pagecontent_trp.TrpTextLineType;
import eu.transkribus.core.model.beans.pagecontent_trp.TrpTextRegionType;
import eu.transkribus.core.util.BeanCopyUtils;
import eu.transkribus.core.util.CoreUtils;
import eu.transkribus.core.util.PrimaUtils;


/**
* <p>Java class for RegionType complex type.
* 
* <p>The following schema fragment specifies the expected content contained within this class.
* 
* <pre>
* &lt;complexType name="RegionType">
*   &lt;complexContent>
*     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
*       &lt;sequence>
*         &lt;element name="Coords" type="{http://schema.primaresearch.org/PAGE/gts/pagecontent/2013-07-15}CoordsType"/>
*         &lt;choice maxOccurs="unbounded" minOccurs="0">
*           &lt;element name="TextRegion" type="{http://schema.primaresearch.org/PAGE/gts/pagecontent/2013-07-15}TextRegionType"/>
*           &lt;element name="ImageRegion" type="{http://schema.primaresearch.org/PAGE/gts/pagecontent/2013-07-15}ImageRegionType"/>
*           &lt;element name="LineDrawingRegion" type="{http://schema.primaresearch.org/PAGE/gts/pagecontent/2013-07-15}LineDrawingRegionType"/>
*           &lt;element name="GraphicRegion" type="{http://schema.primaresearch.org/PAGE/gts/pagecontent/2013-07-15}GraphicRegionType"/>
*           &lt;element name="TableRegion" type="{http://schema.primaresearch.org/PAGE/gts/pagecontent/2013-07-15}TableRegionType"/>
*           &lt;element name="ChartRegion" type="{http://schema.primaresearch.org/PAGE/gts/pagecontent/2013-07-15}ChartRegionType"/>
*           &lt;element name="SeparatorRegion" type="{http://schema.primaresearch.org/PAGE/gts/pagecontent/2013-07-15}SeparatorRegionType"/>
*           &lt;element name="MathsRegion" type="{http://schema.primaresearch.org/PAGE/gts/pagecontent/2013-07-15}MathsRegionType"/>
*           &lt;element name="ChemRegion" type="{http://schema.primaresearch.org/PAGE/gts/pagecontent/2013-07-15}ChemRegionType"/>
*           &lt;element name="MusicRegion" type="{http://schema.primaresearch.org/PAGE/gts/pagecontent/2013-07-15}MusicRegionType"/>
*           &lt;element name="AdvertRegion" type="{http://schema.primaresearch.org/PAGE/gts/pagecontent/2013-07-15}AdvertRegionType"/>
*           &lt;element name="NoiseRegion" type="{http://schema.primaresearch.org/PAGE/gts/pagecontent/2013-07-15}NoiseRegionType"/>
*           &lt;element name="UnknownRegion" type="{http://schema.primaresearch.org/PAGE/gts/pagecontent/2013-07-15}UnknownRegionType"/>
*         &lt;/choice>
*       &lt;/sequence>
*       &lt;attribute name="id" use="required" type="{http://www.w3.org/2001/XMLSchema}ID" />
*       &lt;attribute name="custom" type="{http://www.w3.org/2001/XMLSchema}string" />
*       &lt;attribute name="comments" type="{http://www.w3.org/2001/XMLSchema}string" />
*     &lt;/restriction>
*   &lt;/complexContent>
* &lt;/complexType>
* </pre>
* 
* 
*/
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "RegionType", propOrder = {
 "coords",
 "textRegionOrImageRegionOrLineDrawingRegion"
})
@XmlSeeAlso({
 SeparatorRegionType.class,
 ChartRegionType.class,
 AdvertRegionType.class,
 UnknownRegionType.class,
 MathsRegionType.class,
 TableRegionType.class,
 MusicRegionType.class,
 NoiseRegionType.class,
 GraphicRegionType.class,
 ChemRegionType.class,
 TextRegionType.class,
 ImageRegionType.class,
 LineDrawingRegionType.class
})
public abstract class RegionType implements ITrpShapeType {
	
	private final static Logger logger = LoggerFactory.getLogger(RegionType.class);

 @XmlElement(name = "Coords", required = true)
 protected CoordsType coords;
 @XmlElements({
     @XmlElement(name = "TextRegion", type = TextRegionType.class),
     @XmlElement(name = "ImageRegion", type = ImageRegionType.class),
     @XmlElement(name = "LineDrawingRegion", type = LineDrawingRegionType.class),
     @XmlElement(name = "GraphicRegion", type = GraphicRegionType.class),
     @XmlElement(name = "TableRegion", type = TableRegionType.class),
     @XmlElement(name = "ChartRegion", type = ChartRegionType.class),
     @XmlElement(name = "SeparatorRegion", type = SeparatorRegionType.class),
     @XmlElement(name = "MathsRegion", type = MathsRegionType.class),
     @XmlElement(name = "ChemRegion", type = ChemRegionType.class),
     @XmlElement(name = "MusicRegion", type = MusicRegionType.class),
     @XmlElement(name = "AdvertRegion", type = AdvertRegionType.class),
     @XmlElement(name = "NoiseRegion", type = NoiseRegionType.class),
     @XmlElement(name = "UnknownRegion", type = UnknownRegionType.class)
 })
 protected List<RegionType> textRegionOrImageRegionOrLineDrawingRegion;
 @XmlAttribute(name = "id", required = true)
 @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
 @XmlID
 @XmlSchemaType(name = "ID")
 protected String id;
 @XmlAttribute(name = "custom")
 protected String custom;
 @XmlAttribute(name = "comments")
 protected String comments;
 
 // --- THE NEW SHIT ---
 	@XmlTransient
 	protected TrpObservable observable;
 	@XmlTransient
 	protected Object parent=null;
 	@XmlTransient
	protected CustomTagList customTagList;
 	
 	@XmlTransient
	Object data;
	
	public RegionType() {
		super();
		observable = new TrpObservable(this);
		customTagList = new CustomTagList(this);
	}
	
	public RegionType(TrpPageType page) {
		this();
		setParent(page);
		observable.setChangedAndNotifyObservers(new TrpConstructedWithParentEvent(this));
	}
	
	/** Copy constructor - NOTE: the contained lines are <emph>not</emph> deep copied, only their references! */
	public RegionType(RegionType src) {
		super();
		
		copyFields(src);
	}
	
	@Override public ITrpShapeType copy() {
		throw new NotImplementedException("copy method must be implemented for each type!");
	}
	
	@Override public void copyFields(ITrpShapeType srcShape) {
		if (!(srcShape instanceof TrpTextRegionType))
			return;
		
		RegionType src = (RegionType) srcShape;
		
		// set new id:
//	    id = getName()+"_"+System.currentTimeMillis();
	    id = TrpPageType.getUniqueId("region");

		// copy base fields:
		coords = BeanCopyUtils.copyCoordsType(src.coords);
		// copy child regions
		textRegionOrImageRegionOrLineDrawingRegion = src.textRegionOrImageRegionOrLineDrawingRegion != null ?
			 new ArrayList<RegionType>(src.textRegionOrImageRegionOrLineDrawingRegion) : null;
	    
	    if (src.getCustomTagList() != null)
	    	src.getCustomTagList().writeToCustomTag();
	    if (src.custom != null)
	    	custom = new String(src.custom);
	    
	    if (src.comments != null)
	    	comments = new String(src.comments);
			
		// copy new fields:
		parent = src.parent;
		data = src.data;
		
		customTagList = new CustomTagList(this);
	}
	
//	@Override public void setId(String id) {
//		this.id = id;
//	}
	
	public List<TrpTextRegionType> getTextRegions(boolean recursive) {
		return getTextRegions(getTextRegionOrImageRegionOrLineDrawingRegion(), recursive);
	}
		
	/*
	 * 
	 * added setion to get text regions for table region
	 * -> Is this a problem somewhere else???
	 */
	public static List<TrpTextRegionType> getTextRegions(List<RegionType> textRegionOrImageRegionOrLineDrawingRegion, boolean recursive) {
		List<TrpTextRegionType> res = new ArrayList<TrpTextRegionType>();
				
		for (RegionType region : textRegionOrImageRegionOrLineDrawingRegion) {
			if (region instanceof TextRegionType) {
				res.add((TrpTextRegionType) region);
				if (recursive) {
					res.addAll(region.getTextRegions(true));
				}
			}
			else if(region instanceof TableRegionType){
				for (ITrpShapeType textregionOfTable : region.getChildren(recursive)) {
					if (textregionOfTable instanceof TextRegionType) {
						res.add((TrpTextRegionType) textregionOfTable);
						if (recursive) {
							res.addAll( ((TrpTextRegionType)textregionOfTable).getTextRegions(true));
						}
					}
				}
			}
		}
		
		return res;
	}
	
	public void sortRegions() {
		sortRegions(getTextRegionOrImageRegionOrLineDrawingRegion());
	}
	
	public static void sortRegions(List<RegionType> textRegionOrImageRegionOrLineDrawingRegion) {
		Collections.sort(textRegionOrImageRegionOrLineDrawingRegion, new TrpElementReadingOrderComparator<RegionType>(true));
	}
	
	@Override
	public Object getParent() { return parent; }
	
	@Override
	public void setParent(Object parent) {
		if (parent instanceof RegionType || parent instanceof TrpPageType || parent==null) {
			this.parent = parent;
		} else {
			throw new RuntimeException("Cannot set parent for region to object of type: "+parent.getClass().getSimpleName());
		}
	}
	
	@Override
	public String getName() {
		XmlType t = this.getClass().getAnnotation(XmlType.class);
				
		if (t != null) {
			if (t.name().endsWith("Type"))
				return t.name().substring(0, t.name().length()-4);
			else return t.name();
		} else
			return "UnknownRegionType";
	}
	
	@Override
	public int getLevel() {
		// regions are either on level 0, if they are directly attached to a page or on level 1 elsewise:
		if (RegionTypeUtil.isBlackening(this)) {
			return 4;
		}
		else if (getParent() instanceof RegionType) {
			return ((RegionType) getParent()).getLevel() + 1;
		} else {
			return 0;
		}
	}
	
	@Override public TrpPageType getPage() {
		if (parent instanceof TrpPageType)
			return (TrpPageType) parent;
		else if (parent instanceof RegionType) {
			return ((RegionType)parent).getPage();
		}
		else
			return null;
	}
	
	@Override public ITrpShapeType getSiblingShape(boolean previous) {
		// TODO: implement for RegionType's -> needed???
		return null;
	}

	@Override public void sortChildren(boolean recursive) {
		sortRegions();
		if (recursive) {
			for (RegionType r : getTextRegionOrImageRegionOrLineDrawingRegion()) {
				r.sortRegions();
			}
		}
	}
	
	@Override public void removeChildren() {
		getTextRegionOrImageRegionOrLineDrawingRegion().clear();
		observable.setChangedAndNotifyObservers(new TrpChildrenClearedEvent(this));
	}
	
	@Override
	public List<ITrpShapeType> getChildren(boolean recursive) {
		ArrayList<ITrpShapeType> c = new ArrayList<ITrpShapeType>();
		for (RegionType region : getTextRegionOrImageRegionOrLineDrawingRegion()) {
			c.add(region);
			if (recursive) {
				for (ITrpShapeType o : region.getChildren(recursive)) {
					c.add(o);
				}
			}
		}
				
		return c;
	}
	
	@Override public boolean hasChildren() { 
		return !getTextRegionOrImageRegionOrLineDrawingRegion().isEmpty();
	}
				
	@Override
	public void setCoordinates(String value, Object who) {
		CoordsType coords = new CoordsType();
		coords.setPoints(value);
		setCoords(coords);
		
		observable.setChangedAndNotifyObservers(new TrpCoordsChangedEvent(who));
	}
		
	@Override
	public String getCoordinates() {
		return getCoords().getPoints();
	}	
	
	@Override
	public void reInsertIntoParent() {
		reInsertIntoParent(-1);
	}
	
	@Override
	public void reInsertIntoParent(int index) {
		if (!getPage().getTextRegionOrImageRegionOrLineDrawingRegion().contains(this)) {
			CoreUtils.addOrAppend(getPage().getTextRegionOrImageRegionOrLineDrawingRegion(), this, index);
			getPage().sortRegions();
			observable.setChangedAndNotifyObservers(new TrpReinsertIntoParentEvent(this));
		}
		
	}
	
	@Override
	public void swap(int direction) {
		
		int i = -1;
		i = getPage().textRegionOrImageRegionOrLineDrawingRegion.indexOf(this);
				
		if (direction == 0){
		
			if (i>0){
				Collections.swap(getPage().getTextRegionOrImageRegionOrLineDrawingRegion(), i, i-1);
				setReadingOrder(getReadingOrder()-1, RegionType.class);
				observable.setChangedAndNotifyObservers(new TrpReadingOrderChangedEvent(this));
				
			}
		}
		else if (direction == 1){
			
			if (i >= 0 && i<(getPage().textRegionOrImageRegionOrLineDrawingRegion.size()-1)){
				Collections.swap(getPage().getTextRegionOrImageRegionOrLineDrawingRegion(), i, i+1);
				setReadingOrder(getReadingOrder()+1, RegionType.class);
				observable.setChangedAndNotifyObservers(new TrpReadingOrderChangedEvent(this));
				
			}
		}
		
	}
	

	@Override
	public void removeFromParent() {
//		System.out.println("removing from parent before: "+getPage().getTextRegionOrImageRegionOrLineDrawingRegion().size());
		getPage().getTextRegionOrImageRegionOrLineDrawingRegion().remove(this);
//		System.out.println("removing from parent after: "+getPage().getTextRegionOrImageRegionOrLineDrawingRegion().size());
		observable.setChangedAndNotifyObservers(new TrpRemovedEvent(this));
	}

	@Override public String getUnicodeText() {
		return null;
	}
	
	@Override public void setUnicodeText(String unicode, Object who) { }
	@Override public void editUnicodeText(int start, int end, String replacement, Object who) { }
	@Override public void setTextEquiv(TextEquivType te) { }	
	
	@Override
	public Object getData() { return data; }
	@Override
	public void setData(Object data) { this.data = data; }
	
	@Override 
	public ITrpShapeType getParentShape() {
		if (parent instanceof RegionType) {
			return (RegionType) parent;
		} else
			return null;
	}
	
	@Override public void addTextStyleTag(TextStyleTag s, String addOnlyThisProperty, /*boolean recursive,*/ Object who) {}

	@Override public List<TextStyleTag> getTextStyleTags() { return new ArrayList<>(); }
	
	@Override public void setTextStyle(TextStyleType s) {
	}
	@Override
	public void setTextStyle(TextStyleType s, boolean recursive, Object who) { }
	@Override public TextStyleType getTextStyle() { return null; }
	
	@Override public void setStructure(String structureType, boolean recursive, Object who) { }
	@Override public String getStructure() { return ""; }
	
	@Override public void translate(int x, int y) throws Exception { 
		setCoordinates(PrimaUtils.translatePoints(getCoordinates(), x, y), this);
	}
	
	@Override public void rotate(double degrees) throws Exception {
		setCoordinates(PrimaUtils.rotatePoints(getCoordinates(), Math.toRadians(degrees)), this);
	}
		
	@Override public void setReadingOrder(Integer readingOrder, Object who) {
		CustomTagUtil.setReadingOrder(this, readingOrder, who);
	}
	
	@Override public Integer getReadingOrder() {
		return CustomTagUtil.getReadingOrder(this);
	}
	
	@Override public String print() {
	    return getName()+": id = "+getId()+", text = "+getUnicodeText()
	    		+", level = "+getLevel()+", parent = "+getParent();
	}
	
	@Override public CustomTagList getCustomTagList() { return customTagList; }
	
	// OBSERVABLE STUFF:
	@Override public TrpObservable getObservable() { return observable; }
	@Override public void addObserver(Observer o) { observable.addObserver(o); }
	@Override public void deleteObserver(Observer o) { observable.deleteObserver(o); }
	@Override public void deleteObservers() { observable.deleteObservers(); }    
	

	 // --- END OF THE NEW SHIT ---
	
 /**
  * Gets the value of the coords property.
  * 
  * @return
  *     possible object is
  *     {@link CoordsType }
  *     
  */
 public CoordsType getCoords() {
     return coords;
 }

 /**
  * Sets the value of the coords property.
  * 
  * @param value
  *     allowed object is
  *     {@link CoordsType }
  *     
  */
 public void setCoords(CoordsType value) {
     this.coords = value;
 }

 /**
  * Gets the value of the textRegionOrImageRegionOrLineDrawingRegion property.
  * 
  * <p>
  * This accessor method returns a reference to the live list,
  * not a snapshot. Therefore any modification you make to the
  * returned list will be present inside the JAXB object.
  * This is why there is not a <CODE>set</CODE> method for the textRegionOrImageRegionOrLineDrawingRegion property.
  * 
  * <p>
  * For example, to add a new item, do as follows:
  * <pre>
  *    getTextRegionOrImageRegionOrLineDrawingRegion().add(newItem);
  * </pre>
  * 
  * 
  * <p>
  * Objects of the following type(s) are allowed in the list
  * {@link TextRegionType }
  * {@link ImageRegionType }
  * {@link LineDrawingRegionType }
  * {@link GraphicRegionType }
  * {@link TableRegionType }
  * {@link ChartRegionType }
  * {@link SeparatorRegionType }
  * {@link MathsRegionType }
  * {@link ChemRegionType }
  * {@link MusicRegionType }
  * {@link AdvertRegionType }
  * {@link NoiseRegionType }
  * {@link UnknownRegionType }
  * 
  * 
  */
 public List<RegionType> getTextRegionOrImageRegionOrLineDrawingRegion() {
     if (textRegionOrImageRegionOrLineDrawingRegion == null) {
         textRegionOrImageRegionOrLineDrawingRegion = new ArrayList<RegionType>();
     }
     return this.textRegionOrImageRegionOrLineDrawingRegion;
 }

 /**
  * Gets the value of the id property.
  * 
  * @return
  *     possible object is
  *     {@link String }
  *     
  */
 public String getId() {
     return id;
 }

 /**
  * Sets the value of the id property.
  * 
  * @param value
  *     allowed object is
  *     {@link String }
  *     
  */
 public void setId(String value) {
     this.id = value;
 }

 /**
  * Gets the value of the custom property.
  * 
  * @return
  *     possible object is
  *     {@link String }
  *     
  */
 public String getCustom() {
     return custom;
 }

 /**
  * Sets the value of the custom property.
  * 
  * @param value
  *     allowed object is
  *     {@link String }
  *     
  */
// public void setCustom(String value) {
//     this.custom = value;
// }
@Override public void setCustom(String custom) {
	this.custom = custom;
	customTagList = new CustomTagList(this);
}

 /**
  * Gets the value of the comments property.
  * 
  * @return
  *     possible object is
  *     {@link String }
  *     
  */
 public String getComments() {
     return comments;
 }

 /**
  * Sets the value of the comments property.
  * 
  * @param value
  *     allowed object is
  *     {@link String }
  *     
  */
 public void setComments(String value) {
     this.comments = value;
 }

}

